// Copyright Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import "forge-std/console.sol";
import "forge-std/Test.sol";
import "forge-std/StdJson.sol";

import "./UArchInterpret.sol";
import "src/EmulatorConstants.sol";

pragma solidity ^0.8.0;

library ExternalUArchInterpret {
    function interpret(AccessLogs.Context memory accessLogs)
        external
        pure
        returns (UArchStep.UArchStepStatus)
    {
        return UArchInterpret.interpret(accessLogs);
    }
}

contract UArchInterpretTest is Test {
    using stdJson for string;
    using Memory for uint64;
    using AccessLogs for AccessLogs.Context;

    struct Entry {
        string binaryFilename;
        string finalRootHash;
        string initialRootHash;
        string logFilename;
        uint256 steps;
    }

    uint8 constant REGISTERS_LENGTH = 35;
    uint8 constant TEST_STATUS_X = 1;
    // test result code
    bytes8 constant TEST_SUCEEDED = 0x00000000be1e7aaa; // Indicates that test has passed
    bytes8 constant TEST_FAILED = 0x00000000deadbeef; // Indicates that test has failed
    string constant CATALOG_PATH = "catalog.json";
    string constant JSON_PATH = "./test/uarch-log/";
    string constant BINARIES_PATH = "./test/uarch-bin/";

    function testBinaries() public {
        Entry[] memory catalog =
            loadCatalog(string.concat(JSON_PATH, CATALOG_PATH));

        for (uint256 i = 0; i < catalog.length; i++) {
            if (bytes(catalog[i].binaryFilename).length == 0) {
                // Skip entries with empty binaryFilename.
                // These entries represent log files generated by the Cartesi machine API, e.g: log_uarch_reset
                continue;
            }

            console.log("Testing %s ...", catalog[i].binaryFilename);
            AccessLogs.Context memory a = newAccessLogsContext();

            // load ramAccessLogs
            loadBin(
                a.buffer,
                string.concat(BINARIES_PATH, catalog[i].binaryFilename)
            );
            // init pc to ram start
            EmulatorCompat.writePc(a, EmulatorConstants.UARCH_RAM_START_ADDRESS);
            // init cycle to 0
            EmulatorCompat.writeCycle(a, 0);

            UArchInterpret.interpret(a);

            uint64 x = EmulatorCompat.readX(a, TEST_STATUS_X);
            assertEq(
                // read test result from the register
                x,
                uint64(TEST_SUCEEDED)
            );

            bool halt = EmulatorCompat.readHaltFlag(a);
            assertTrue(halt, "machine should halt");

            uint64 cycle = EmulatorCompat.readCycle(a);
            assertEq(cycle, catalog[i].steps, "cycle values should match");
        }
    }

    function testStepEarlyReturn() public {
        AccessLogs.Context memory a = newAccessLogsContext();

        // init pc to ram start
        EmulatorCompat.writePc(a, EmulatorConstants.UARCH_RAM_START_ADDRESS);
        // init cycle to uint64.max
        EmulatorCompat.writeCycle(a, type(uint64).max);

        UArchStep.UArchStepStatus status = UArchInterpret.interpret(a);

        assertTrue(
            status == UArchStep.UArchStepStatus.CycleOverflow,
            "machine should be cycle overflow"
        );

        uint64 cycle = EmulatorCompat.readCycle(a);
        assertEq(
            cycle,
            type(uint64).max,
            "step should not advance when cycle is uint64.max"
        );

        // reset cycle to 0
        EmulatorCompat.writeCycle(a, 0);
        // set machine to halt
        EmulatorCompat.setHaltFlag(a);

        status = UArchInterpret.interpret(a);

        assertTrue(
            status == UArchStep.UArchStepStatus.UArchHalted,
            "machine should halt"
        );
    }

    function testIllegalInstruction() public {
        AccessLogs.Context memory a = newAccessLogsContext();

        // init pc to ram start
        EmulatorCompat.writePc(a, EmulatorConstants.UARCH_RAM_START_ADDRESS);
        // init cycle to 0
        EmulatorCompat.writeCycle(a, 0);

        vm.expectRevert("illegal instruction");
        ExternalUArchInterpret.interpret(a);
    }

    function loadBin(Buffer.Context memory buffer, string memory path)
        private
        view
    {
        bytes memory bytesData = vm.readFileBinary(path);
        buffer.data = bytes.concat(buffer.data, bytesData);
    }

    function loadCatalog(string memory path)
        private
        view
        returns (Entry[] memory)
    {
        string memory json = vm.readFile(path);
        bytes memory raw = json.parseRaw("");
        Entry[] memory catalog = abi.decode(raw, (Entry[]));

        return catalog;
    }

    function newAccessLogsContext()
        private
        pure
        returns (AccessLogs.Context memory)
    {
        return AccessLogs.Context(
            bytes32(0),
            Buffer.Context(new bytes(uint128(REGISTERS_LENGTH) * 8), 0)
        );
    }
}
